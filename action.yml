name: 'Deploy ArgoCD'
description: 'Deploy on Kubernetes with ArgoCD'
author: hello@cloudposse.com
branding:
  icon: 'cpu'
  color: 'white'
inputs:
  cluster:
    description: Cluster name
    required: true
  aws-region:
    description: AWS region
    required: false
    default: us-east-1
  path:
    description: The path where lives the helmfile or helm chart.
    required: true
  toolchain:
    description: Toolchain ('helm', 'helmfile')
    required: false
    default: helmfile
  ssm-path:
    required: true
    description: SSM path to read environment secrets
  operation:
    description: Operation with helmfiles. (valid options - `deploy`, `destroy`)
    required: true
    default: deploy
  environment:
    description: Helmfile environment
    required: false
    default: preview
  repository:
    description: Application GitHub repository full name
    required: true
  ref:
    description: Git ref
    required: true
  gitref-sha:
    description: Git SHA (Depricated. Use `ref` instead)
    required: false
    default: ''
  namespace:
    description: Kubernetes namespace
    required: true
  application:
    description: Application name
    required: true
  image:
    description: Docker image
    required: true
  image-tag:
    description: Docker image tag
    required: true
  debug:
    description: Debug mode
    default: 'false'
    required: false
  values_file:
    description: Helmfile values file
    default: ""
    required: false
  release_label_name:
    description: The name of the label used to describe the helm release
    default: "release"
    required: false
  github-pat:
    description: Github PAT to access argocd configuration repository
    required: true
  synchronously:
    description: "Wait until ArgoCD successfully apply the changes"
    default: 'false'
  check-timeout:
    description: 'Timeout check (in seconds) (for synchronously mode)'
    required: false
    default: "600"
  check-retry-count:
    description: 'Check retry count (for synchronously mode)'
    required: false
    default: "5"
  check-retry-interval:
    description: 'Check retry interval (in seconds) (for synchronously mode)'
    required: false
    default: "10"
outputs:
  webapp-url:
    description: "Web Application url"
    value: ${{ steps.result.outputs.webapp_url }}
  sha:
    description: "Git commit SHA into argocd repo"
    value: ${{ steps.git.outputs.sha }}
runs:
  using: "composite"
  steps:
    - name: Setup yq
      uses: dcarbone/install-yq-action@v1.1.0
      with:
        version: v4.28.1
        download-compressed: true
        force: true

    - name: Setup helmfile
      uses: mamezou-tech/setup-helmfile@v1.2.0
      if: ${{ inputs.operation == 'deploy' }}
      with:
        helmfile-version: v0.148.1
        helm-version: v3.10.2
        install-kubectl: false

    - id: destination
      uses: theowenyoung/git-url-parse@v1
      with:
        url: ${{ inputs.cluster }}

    - id: destination_dir
      shell: bash
      run: |-
        echo "name=$(echo $RANDOM | md5sum | head -c 20)" >> $GITHUB_OUTPUT

    - name: Config
      id: config
      uses: cloudposse/github-action-yaml-config-query@0.1.3
      with:
        config: |-
          tmp: ./tmp/${{ steps.destination.outputs.filepath }}/${{ inputs.namespace }}/${{ inputs.application }}
          path: ${{ steps.destination.outputs.filepath }}/${{ inputs.namespace }}/${{ inputs.application }}

    - name: Checkout Argo Configuration
      uses: actions/checkout@v3
      with:
        repository: ${{ steps.destination.outputs.owner }}/${{ steps.destination.outputs.name }}
        ref: ${{ steps.destination.outputs.ref }}
        token: ${{ inputs.github-pat }}
        path: ${{ steps.destination_dir.outputs.name }}

    - name: Read platform context
      uses: docker://public.ecr.aws/u3q6g8t1/chamber:2.10.12
      if: ${{ inputs.operation == 'deploy' }}
      with:
        args: --verbose export ${{ inputs.ssm-path }}/${{ inputs.environment }} --format yaml --output-file ./platform.yaml

    - name: YQ Platform settings
      if: ${{ inputs.operation == 'deploy' }}
      shell: bash
      run: |
        sudo chmod 777 ./platform.yaml 
        yq --exit-status --no-colors --inplace eval '{"platform": .}' ./platform.yaml

    - name: Read platform metadata
      uses: docker://public.ecr.aws/u3q6g8t1/chamber:2.10.12
      if: ${{ inputs.operation == 'deploy' }}
      with:
        args: --verbose export ${{ inputs.ssm-path }}/_metadata --format yaml --output-file ./_metadata.yaml

    - name: YQ Platform settings
      if: ${{ inputs.operation == 'deploy' }}
      shell: bash
      id: metadata
      run: |
        for output in $(yq --exit-status --no-colors eval-all '. | to_entries | map( .key + "=" + .value ) | join("\n")' ./_metadata.yaml); do
          echo "${output}" >> $GITHUB_OUTPUT ;
        done

    - name: Context
      if: ${{ inputs.operation == 'deploy' }}
      id: arguments
      uses: cloudposse/github-action-yaml-config-query@0.1.3
      with:
        query: .${{ steps.metadata.outputs.kube_version == '' }}
        config: |-
          true: 
            kube_version: ""
          false:
            kube_version: --kube-version=${{ steps.metadata.outputs.kube_version }}      


    - name: Ensure argocd repo structure
      if: ${{ inputs.operation == 'deploy' }}
      shell: bash
      run: |
        mkdir -p ${{ steps.config.outputs.tmp }}/manifests

    - name: Helmfile render
      if: ${{ inputs.toolchain == 'helmfile' && inputs.operation == 'deploy' }}
      shell: bash
      run: |
        helmfile --namespace ${{ inputs.namespace }} \
          --environment ${{ inputs.environment }} \
          --file ${{ inputs.path}} \
          --state-values-file $(pwd)/platform.yaml \
          template \
          --args="${{ steps.arguments.outputs.kube_version }}" \
          > ${{ steps.config.outputs.tmp }}/manifests/resources.yaml
      env:
        IMAGE_NAME: ${{ inputs.image }}
        IMAGE_TAG: ${{ inputs.image-tag }}

    - name: Helm raw render
      if: ${{ inputs.toolchain == 'helm' && inputs.operation == 'deploy' }}
      shell: bash
      run: |
        helm template ${{ inputs.application }} ${{ inputs.path }} \
          --set image.repository=${{ inputs.image }} \
          --set image.tag=${{ inputs.image-tag }} \
          --set environment=${{ inputs.environment }} \
          --create-namespace=true \
          --namespace ${{ inputs.namespace }} \
          --set ingress.default.hosts.example=test \
          --values $(pwd)/platform.yaml \
          --values "${{ inputs.values_file }}" \
          ${{ steps.arguments.outputs.kube_version }} \
        > ${{ steps.config.outputs.tmp }}/manifests/resources.yaml
      env:
        IMAGE_NAME: ${{ inputs.image }}
        IMAGE_TAG: ${{ inputs.image-tag }}

    - name: Get Webapp
      if: ${{ inputs.operation == 'deploy' }}
      id: result
      shell: bash
      run: |-
        WEBAPP_URL=$( \
          yq eval-all '.metadata.annotations["outputs.platform.cloudposse.com/webapp-url"] | select(. != null)' \
            ${{ steps.config.outputs.tmp }}/manifests/resources.yaml \
        )
        echo "webapp_url=${WEBAPP_URL}" >> $GITHUB_OUTPUT

    - name: Deplicated Ref
      if: ${{ inputs.operation == 'deploy' }}
      id: ref
      uses: cloudposse/github-action-yaml-config-query@0.1.3
      with:
        query: .${{ inputs.gitref-sha == '' }}
        config: |-
          true: 
            value: ${{ inputs.ref }}
          false:
            value: ${{ inputs.gitref-sha }}      

    - name: Config render
      if: ${{ inputs.operation == 'deploy' }}
      uses: 1arp/create-a-file-action@0.2
      with:
        path: ${{ steps.config.outputs.tmp }}
        file: config.yaml
        content: |-
          app_repository: ${{ inputs.repository }}
          app_commit: ${{ steps.ref.outputs.value }}
          app_hostname: ${{ steps.result.outputs.webapp_url }}
          name: ${{ inputs.namespace }}.${{ inputs.application }}
          namespace: ${{ inputs.namespace }}
          manifests: ${{ steps.config.outputs.path }}/manifests

    - name: Push to Github
      uses: nick-fields/retry@v2
      id: git
      with:
        timeout_minutes: 1
        max_attempts: 4
        shell: bash
        command: |-
          set -e
          
          git config --global user.email "bot@example.com"
          git config --global user.name "cloudpossebot"

          pushd ./${{ steps.destination_dir.outputs.name }}
          
          git reset --hard origin/${{ steps.destination.outputs.ref }}
          git pull --rebase
          
          popd
          
          case '${{ inputs.operation }}' in
        
            deploy)
              cp -r ./tmp/* ./${{ steps.destination_dir.outputs.name }}/
            ;;
          
            destroy)
              rm -rf ./${{ steps.destination_dir.outputs.name }}/${{ steps.config.outputs.path }}
            ;;
          
            *)
              echo "Operation should be `deploy` or `destroy`"
              exit 1;
            ;;
          esac          
          
          pushd ./${{ steps.destination_dir.outputs.name }}
          
          git add -A
          git status
          git diff-index --quiet HEAD || git commit -m "Deploy ${{ github.repository }} SHA ${{ github.sha }} RUN ${{ github.run_id }} ATEMPT ${{ github.run_attempt }}"
          git push origin ${{ steps.destination.outputs.ref }}

          echo "sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
          
          popd

    - uses: actions/github-script@v6
      if: ${{ inputs.synchronously == 'true' && inputs.operation == 'deploy' }}
      with:
        github-token: ${{ inputs.github-pat }}
        script: |
          // Function to wait for a specific commit status to become a success
          async function waitForCommitStatusSuccess(owner, repo, commitSha, statusContext, options = {}) {
            const { timeout = 300000, retryCount = 10, retryInterval = 5000 } = options;
            const startTime = Date.now();
          
            let attemptCount = 0;
          
            while (true) {
              const { data: statuses } = await github.rest.repos.listCommitStatusesForRef({
                owner,
                repo,
                ref: commitSha,
              });
          
              const matchingStatus = statuses.find((status) => status.context === statusContext);
              if (matchingStatus && matchingStatus.state === "success") {
                console.log(`Commit status "${statusContext}" is now a success.`);
                return true;
              }
          
              attemptCount++;
          
              if (attemptCount >= retryCount) {
                console.log(`Exceeded maximum retry count. Exiting...`);
                return false;
              }
          
              const elapsedTime = Date.now() - startTime;
              if (elapsedTime >= timeout) {
                console.log(`Timeout reached. Exiting...`);
                return false;
              }
          
              console.log(`Waiting for commit status "${statusContext}" to become a success...`);
          
              await new Promise((resolve) => setTimeout(resolve, retryInterval));
            }
          }
          
          // Usage
          const options = {
            timeout: 1000 * ${{ inputs.check-timeout }}, // Convert from seconds to milliseconds
            retryCount: ${{ inputs.check-retry-count }}, // Retry 5 times before giving up
            retryInterval: 1000 * ${{ inputs.check-retry-interval }} // Convert from seconds to milliseconds
          };
          
          owner = "${{ inputs.repository }}".split("/")[0]
          repo = "${{ inputs.repository }}".split("/")[1]

          waitForCommitStatusSuccess(owner, repo, "${{ inputs.ref }}", "continuous-delivery/${{ inputs.namespace }}.${{ inputs.application }}", options)
            .then((result) => {
              console.log("Done waiting.");
              if (result) {
                process.exit(0)
              }
              process.exit(1)
            })
            .catch((error) => {
              console.error("Error:", error);
              process.exit(1); // Exit with status code 1
            });          
